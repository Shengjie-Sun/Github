### 为什么要用动态规划？

减少递归中的重复计算

### 什么问题适合用动态规划解决？

**多阶段决策最优解模型**

一般是优化问题：最短路径

整个问题可以拆分成**多个决策阶段**，每个阶段的决策结果可总结/保存为一个状态。

寻找一组决策序列，通过这组决策序列可产生最终期望的最优值。

**序列比对问题**：最长公共子串

**连续决策问题**：0-1背包问题



### 动态规划算法的特征？

1. **最优子结构**

   问题的最优解包含子问题的最优解。子问题的最优解，可推导出问题的最优解。

2. **无后效性**

   推导当前状态时只关心之前的状态值（递推关系式），因此需要边界条件。某个状态一旦确定，则不受之前阶段状态的决策影响。

3. **重复子问题**



### 搭建动态规划算法的思路？

1. **从后往前，从简单到复杂，递归式的思考**

   一般能用动态规划解决的问题，都可以使用递归算法的暴力解决。先思考最后任务快完成的情况，寻求`递归关系`。再寻找递归算法中的`重复子问题`，并找到合适的`状态定义`，设计`递推关系`。递推关系需要起始值，一般递推关系的起始即为递归关系的终止条件。最后设计动态规划算法，考虑状态跟新的顺序，空间的优化等等。

2. 状态转移方程法

3. 



0-1 Knapsack with weights and values

- 状态定义：

  $states(n, W)$ 表示前$n$个物品在重量为$W$的限制下，最多能达到的价值。二维矩阵，逐行更新。

- 递归关系式：

  $$states(n, W) = max(states(n-1, W), states(n-1, W-w_n)+v_n)$$

- 思路总结：

  `连续决策`问题。状态与递归关系式的思考过程为当前的状态是如何得到的，分情况讨论，`分而治之`。写代码的时候注意递归基的定义，以及index越界的处理。

416-Medium-Partition Equal Subset Sum

- 思路总结：

  0-1 Knapsack的变体，若存在可以装满背包（所有数和的一半）的array的子集，则存在这样的partition。

1049-Medium-Last Stone Weight II

- 思路总结：

  0-1 Knapsack的变体，背包问题的变体，撞的石头为减去自身重量（-）， 被撞的石头为加上自身重要（+）。原来的背包问题中物体是可选可不选，这题的物体是加上或者是减去。

1143-Medium-Longest Common Subsequence

- 状态定义：

  $states(i, j)$ 表示第一了字符串的前$i$个与第二个字符串的前$j$的最长公共子串的长度。二维矩阵，逐行或者是逐列更新。

- 递归关系式：

  $$\begin{equation} states(i, j)= \left\{ \begin{aligned} & states(i-1, j-1) + 1 & text1[i] = text2[j] \\ & max\{states(i-1, j), states(i, j-1)\} & otherwise \end{aligned} \right. \end{equation}$$

- 思路总结：

  `序列比对`问题。状态与递归关系式的思考过程为思考两个序列的最后一个元素的处理，处理完之后就不再考虑该元素，`剪而治之`， 同时对问题`分而治之`。写代码的时候注意递归基的定义。

- 

